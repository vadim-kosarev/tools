<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Request Monitor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            font-size: 24px;
            margin: 10px 0 20px;
        }
        .status-bar {
            padding: 10px;
            margin-bottom: 20px;
            background-color: #e8f5e9;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }
        .status-bar > span {
            margin: 5px;
            flex: 1 0 auto;
        }
        .record-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        .record-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .new-record {
            animation: highlight 2s ease-in-out;
        }
        @keyframes highlight {
            0% {
                background-color: #ffff99;
            }
            100% {
                background-color: #fff;
            }
        }
        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .record-id {
            font-weight: bold;
            color: #0066cc;
        }
        .record-date {
            font-size: 12px;
            color: #666;
        }
        .record-field {
            margin: 8px 0;
        }
        .field-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 3px;
            font-weight: 500;
        }
        .field-value {
            font-size: 14px;
            word-break: break-word;
        }
        .phone-value {
            font-weight: bold;
            color: #333;
        }
        .phone-link {
            color: #0066cc;
            text-decoration: none;
            display: inline-block;
            padding: 6px 12px;
            background-color: #e6f2ff;
            border-radius: 20px;
            margin-top: 4px;
            border: 1px solid #cce0ff;
            transition: all 0.2s ease;
        }
        .phone-link:hover, .phone-link:active {
            background-color: #cce0ff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .phone-link:before {
            content: "üìû ";
            margin-right: 4px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 8px 12px;
            background-color: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex: 1 0 auto;
            min-width: 80px;
        }
        button:hover {
            background-color: #0052a3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #poll-interval {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 80px;
            flex: 2 0 auto;
        }
        .interval-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
        }
        label {
            font-size: 14px;
            white-space: nowrap;
        }
        .no-data-message {
            text-align: center;
            padding: 40px 0;
            color: #666;
        }
        #records-container {
            margin-top: 15px;
        }
        .sound-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: auto;
            cursor: pointer;
        }
        .sound-toggle input {
            margin: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
            .status-bar > span {
                width: 100%;
                margin: 3px 0;
            }
            .controls {
                flex-direction: column;
            }
            h1 {
                font-size: 20px;
            }
            .record-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .record-date {
                margin-top: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Live Request Monitor</h1>

        <div class="status-bar">
            <span>Monitoring since: <span id="monitor-since"></span></span>
            <span>Last check: <span id="last-check">Never</span></span>
            <span>Records found: <span id="records-count">0</span></span>
        </div>

        <div class="controls">
            <button id="toggle-polling">Pause</button>
            <div class="interval-container">
                <label for="poll-interval">Poll interval (ms):</label>
                <input type="number" id="poll-interval" value="5000" min="1000">
            </div>
            <button id="reset-timestamp">Reset Timestamp</button>
            <label class="sound-toggle">
                <input type="checkbox" id="sound-toggle" checked>
                –ó–≤—É–∫–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            </label>
            <button id="test-sound">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–≤—É–∫</button>
        </div>

        <div id="table-container">
            <div id="records-container">
                <!-- Records will be displayed as cards here -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // State variables
            let initialTimestamp = Date.now();
            let isPolling = true;
            let pollingInterval = 5000; // 5 seconds default
            let recordsFound = 0;
            let pollingTimer = null;
            let isSoundEnabled = true;

            // Elements
            const recordsContainer = document.getElementById('records-container');
            const monitorSinceElement = document.getElementById('monitor-since');
            const lastCheckElement = document.getElementById('last-check');
            const recordsCountElement = document.getElementById('records-count');
            const togglePollingButton = document.getElementById('toggle-polling');
            const pollIntervalInput = document.getElementById('poll-interval');
            const resetTimestampButton = document.getElementById('reset-timestamp');
            const soundToggle = document.getElementById('sound-toggle');
            const testSoundButton = document.getElementById('test-sound');

            // Format and display the initial timestamp
            const formatDateTime = (timestamp) => {
                const date = new Date(timestamp);
                return date.toLocaleString();
            };

            monitorSinceElement.textContent = formatDateTime(initialTimestamp);

            // Function to poll the API for new records
            const pollForNewRecords = async () => {
                if (!isPolling) return;

                try {
                    const url = `/api/list?timestamp_ms=${initialTimestamp}&order=created_at:asc`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }

                    const data = await response.json();
                    lastCheckElement.textContent = formatDateTime(Date.now());

                    // If we have new records, display them
                    if (data.data && data.data.length > 0) {
                        // Update records count
                        recordsFound += data.data.length;
                        recordsCountElement.textContent = recordsFound;

                        // Render new records in the table
                        renderNewRecords(data.data);

                        // Play notification sound if enabled
                        if (isSoundEnabled) {
                            playNotificationSound();
                        }

                        // Update our timestamp to the latest record's timestamp + 1
                        const latestRecord = data.data.reduce((latest, current) => {
                            return current.created_at > latest.created_at ? current : latest;
                        }, data.data[0]);

                        initialTimestamp = latestRecord.created_at + 1;
                    }
                } catch (error) {
                    console.error('Error polling for new records:', error);
                } finally {
                    // Schedule the next poll if we're still in polling mode
                    if (isPolling) {
                        pollingTimer = setTimeout(pollForNewRecords, pollingInterval);
                    }
                }
            };

            // Function to render new records
            const renderNewRecords = (records) => {
                records.forEach(record => {
                    const card = document.createElement('div');
                    card.classList.add('record-card', 'new-record');

                    // Format date
                    let createdAt = record.created_at;
                    if (createdAt) {
                        const date = new Date(parseInt(createdAt));
                        if (!isNaN(date.getTime())) {
                            createdAt = formatDateTime(date);
                        }
                    }

                    // Create record header
                    const header = document.createElement('div');
                    header.classList.add('record-header');

                    const idElement = document.createElement('div');
                    idElement.classList.add('record-id');
                    idElement.textContent = `ID: ${record.id || '-'}`;

                    const dateElement = document.createElement('div');
                    dateElement.classList.add('record-date');
                    dateElement.textContent = createdAt || '-';

                    header.appendChild(idElement);
                    header.appendChild(dateElement);
                    card.appendChild(header);

                    // Create record fields
                    const fields = [
                        { label: 'Token', value: record.token },
                        { label: 'Phone', value: record.phone, isPhone: true },
                        { label: 'Client IP', value: record.clientIP }
                    ];

                    fields.forEach(field => {
                        const fieldDiv = document.createElement('div');
                        fieldDiv.classList.add('record-field');

                        const label = document.createElement('div');
                        label.classList.add('field-label');
                        label.textContent = field.label;

                        fieldDiv.appendChild(label);

                        if (field.isPhone && field.value && field.value !== '-') {
                            // Format the phone number for dialing
                            // Extract the first digit after the + symbol (if it exists)
                            let cleanPhoneNumber = field.value.replace(/\D/g, '');

                            // Add the + prefix to ensure international dialing works properly
                            cleanPhoneNumber = '+' + cleanPhoneNumber;

                            // Create a text display for the formatted phone number
                            const textDisplay = document.createElement('div');
                            textDisplay.classList.add('field-value', 'phone-value');
                            textDisplay.textContent = field.value;
                            fieldDiv.appendChild(textDisplay);

                            // Create a clickable link for calling
                            const phoneLink = document.createElement('a');
                            phoneLink.href = `tel:${cleanPhoneNumber}`;
                            phoneLink.classList.add('phone-link');
                            phoneLink.textContent = 'Call';
                            fieldDiv.appendChild(phoneLink);
                        } else {
                            // For non-phone fields, display as normal text
                            const value = document.createElement('div');
                            value.classList.add('field-value');
                            value.textContent = field.value || '-';
                            fieldDiv.appendChild(value);
                        }

                        card.appendChild(fieldDiv);
                    });

                    // Insert at the top of the container
                    if (recordsContainer.firstChild) {
                        recordsContainer.insertBefore(card, recordsContainer.firstChild);
                    } else {
                        recordsContainer.appendChild(card);
                    }
                });
            };

            // Function to play sound
            const playSound = () => {
                // Using Web Audio API to play a simple beep sound
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = context.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, context.currentTime); // 440 Hz is the A4 note
                oscillator.connect(context.destination);
                oscillator.start();
                oscillator.stop(context.currentTime + 0.2); // Play sound for 200ms
            };

            // Try to play sound on page load (may be blocked by browser)
            playSound();

            // Function to play sound with specific frequency and duration
            const playTone = (frequency, duration) => {
                return new Promise(resolve => {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                        // Add fade in/out to avoid clicks
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
                        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + duration);

                        setTimeout(() => {
                            resolve();
                            // Close the audio context after a delay to ensure the sound is fully played
                            setTimeout(() => {
                                if (audioContext.state !== 'closed') {
                                    audioContext.close().catch(() => {});
                                }
                            }, 500);
                        }, duration * 1000 + 50);
                    } catch (error) {
                        console.error('Error playing tone:', error);
                        resolve(); // Resolve anyway to continue the sequence
                    }
                });
            };

            // Function to play a sequence of tones with pauses between them
            const playToneSequence = async (tones) => {
                for (const tone of tones) {
                    await playTone(tone.freq, tone.duration);
                    if (tone.pause) {
                        await new Promise(resolve => setTimeout(resolve, tone.pause * 1000));
                    }
                }
            };

            // Try to initialize audio context on page load (will likely be suspended until user interaction)
            let audioContextInitialized = false;
            try {
                const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                if (tempContext.state === 'running') {
                    audioContextInitialized = true;
                }
                // Either suspend or close, depending on browser capability
                if (tempContext.state !== 'closed') {
                    if (tempContext.suspend && tempContext.state !== 'suspended') {
                        tempContext.suspend().catch(() => {});
                    } else if (tempContext.close) {
                        tempContext.close().catch(() => {});
                    }
                }
            } catch (e) {
                console.log('Audio API not fully supported in this browser');
            }

            // Unlock audio on first user interaction
            const unlockAudio = () => {
                try {
                    const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                    const emptySource = tempContext.createBufferSource();
                    emptySource.start();
                    emptySource.stop();
                    audioContextInitialized = true;
                    console.log('–ê—É–¥–∏–æ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –ø–æ—Å–ª–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è');
                } catch (e) {
                    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ:', e);
                }

                // Remove event listeners once audio is unlocked
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
            };

            // Add event listeners for unlocking audio
            document.addEventListener('click', unlockAudio);
            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('keydown', unlockAudio);

            // Play notification sound - —Ç—Ä–∏ –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–∏–≥–Ω–∞–ª–∞ –∏ –¥–≤–∞ –¥–ª–∏–Ω–Ω—ã—Ö –∑–≤—É–∫–æ–º –Ω–∏–∂–µ
            const playNotificationSound = async () => {
                if (!isSoundEnabled) return;

                // Sequence: —Ç—Ä–∏ –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–∏–≥–Ω–∞–ª–∞ –∏ –¥–≤–∞ –¥–ª–∏–Ω–Ω—ã—Ö –∑–≤—É–∫–æ–º –Ω–∏–∂–µ
                const sequence = [
                    { freq: 880, duration: 0.1, pause: 0.1 },  // –∫–æ—Ä–æ—Ç–∫–∏–π —Å–∏–≥–Ω–∞–ª 1
                    { freq: 880, duration: 0.1, pause: 0.1 },  // –∫–æ—Ä–æ—Ç–∫–∏–π —Å–∏–≥–Ω–∞–ª 2
                    { freq: 880, duration: 0.1, pause: 0.2 },  // –∫–æ—Ä–æ—Ç–∫–∏–π —Å–∏–≥–Ω–∞–ª 3
                    { freq: 440, duration: 0.3, pause: 0.2 },  // –¥–ª–∏–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª 1 (–Ω–∏–∂–µ)
                    { freq: 440, duration: 0.3, pause: 0.1 }   // –¥–ª–∏–Ω–Ω—ã–π —Å–∏–≥–Ω–∞–ª 2 (–Ω–∏–∂–µ)
                ];

                try {
                    await playToneSequence(sequence);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–æ–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:', error);
                }
            };

            // Toggle polling
            togglePollingButton.addEventListener('click', function() {
                isPolling = !isPolling;
                this.textContent = isPolling ? 'Pause' : 'Resume';

                if (isPolling) {
                    pollForNewRecords();
                } else if (pollingTimer) {
                    clearTimeout(pollingTimer);
                }
            });

            // Update polling interval
            pollIntervalInput.addEventListener('change', function() {
                const newInterval = parseInt(this.value);
                if (!isNaN(newInterval) && newInterval >= 1000) {
                    pollingInterval = newInterval;

                    // Restart polling with new interval
                    if (isPolling && pollingTimer) {
                        clearTimeout(pollingTimer);
                        pollForNewRecords();
                    }
                }
            });

            // Reset timestamp button
            resetTimestampButton.addEventListener('click', function() {
                initialTimestamp = Date.now();
                monitorSinceElement.textContent = formatDateTime(initialTimestamp);

                // Clear existing records
                recordsContainer.innerHTML = '';
                recordsFound = 0;
                recordsCountElement.textContent = '0';

                // Restart polling
                if (isPolling && pollingTimer) {
                    clearTimeout(pollingTimer);
                    pollForNewRecords();
                }
            });

            // Sound toggle
            soundToggle.addEventListener('change', function() {
                isSoundEnabled = this.checked;
            });

            // Test sound button
            testSoundButton.addEventListener('click', function() {
                if (isSoundEnabled) {
                    playNotificationSound();
                }
            });

            // Start polling
            pollForNewRecords();
        });
    </script>
</body>
</html>
