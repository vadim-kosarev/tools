#!/usr/bin/env python3# -*- coding: utf-8 -*-"""GigaAM-v3 транскрибация для длинных аудио/видео файлов.Простая версия без диаризации спикеров."""import argparseimport sysimport tempfileimport loggingfrom pathlib import Pathimport torchfrom transformers import AutoModel# Импорт конфигурации и утилитfrom transcribe_config import (    setup_ffmpeg_path,    HF_TOKEN,    CHUNK_SEC,    OVERLAP_SEC,    GIGAAM_MODEL_NAME,    GIGAAM_DEFAULT_REVISION,    GIGAAM_AVAILABLE_REVISIONS,    LOG_LEVEL,    LOG_FORMAT)from transcribe_utils import (    is_video_file,    extract_audio_from_video,    cut_audio_to_chunks,    cleanup_chunk_files,    cleanup_temp_file,    save_transcription_to_file)# Настройка FFmpeg и логированияsetup_ffmpeg_path()logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)logger = logging.getLogger(__name__)def transcribe_file(        file_path: str,        revision: str = GIGAAM_DEFAULT_REVISION,        device: str = "cuda" if torch.cuda.is_available() else "cpu",        chunk_sec: float = CHUNK_SEC,):    """Транскрибирует аудио/видеофайл"""    input_path = Path(file_path)    logger.info(f"Начало обработки: {input_path.name}")    # Создаём временную директорию    tmp_dir = Path(tempfile.mkdtemp(prefix="gigaam_process_"))    audio_path = None    # Проверяем, является ли файл видео    is_video = is_video_file(input_path)    if is_video:        logger.info(f"Обнаружен видеофайл: {input_path.suffix}")        audio_path = extract_audio_from_video(input_path, tmp_dir)        process_path = str(audio_path)    else:        logger.info(f"Обнаружен аудиофайл: {input_path.suffix}")        process_path = file_path    logger.info(f"→ Загружаем GigaAM-v3 ({revision}) на {device.upper()}...")    model = AutoModel.from_pretrained(        GIGAAM_MODEL_NAME,        revision=revision,        trust_remote_code=True,    )    model.to(device)    model.eval()    logger.info(f"✓ Модель загружена на {device.upper()}")    chunking_result = cut_audio_to_chunks(process_path, chunk_sec=chunk_sec, overlap_sec=OVERLAP_SEC)    texts = []    for i, chunk in enumerate(chunking_result.chunks, 1):        logger.info(f"→ Транскрипция чанка {i}/{len(chunking_result.chunks)} ({chunk.file_path.name})...")        # Проверяем размер чанка        try:            chunk_size = chunk.file_path.stat().st_size            if chunk_size == 0:                logger.warning(f"  Чанк {i} пустой (0 байт), пропускаем")                continue        except OSError as e:            logger.error(f"  Ошибка чтения файла чанка {i}: {e}")            continue        try:            with torch.inference_mode():                text = model.transcribe(str(chunk.file_path))            # Добавляем маркер [...] только для непустых чанков            chunk_text = text.strip()            if chunk_text:  # Только если есть текст                chunk_text = chunk_text + " [...]"                texts.append(chunk_text)                logger.info(f"  {chunk_text[:80]}...")            else:                logger.debug(f"  Пропущен пустой чанк {i}")        except Exception as e:            logger.error(f"  Ошибка транскрипции чанка {i}: {type(e).__name__} → {e}")            logger.debug(f"  Чанк будет пропущен, продолжаем обработку...")            continue    full_text = " ".join(texts)    # Очистка    cleanup_chunk_files(chunking_result.chunks)    if is_video and audio_path:        cleanup_temp_file(audio_path)    if tmp_dir.exists():        try:            tmp_dir.rmdir()        except:            pass    # Сохранение    output_path = save_transcription_to_file(full_text, input_path, revision, suffix="simple")    logger.info(f"Готово → {output_path}")def main():    parser = argparse.ArgumentParser(description="GigaAM-v3 для длинных аудио/видео")    parser.add_argument("input", nargs="+", help="файл или папка")    parser.add_argument("--revision", default=GIGAAM_DEFAULT_REVISION,                        choices=GIGAAM_AVAILABLE_REVISIONS)    parser.add_argument("--device", default="auto", choices=["auto", "cpu", "cuda"])    parser.add_argument("--chunk", type=float, default=CHUNK_SEC, help="длина чанка (сек)")    args = parser.parse_args()    # Определение устройства    cuda_available = torch.cuda.is_available()    if args.device == "auto":        device = "cuda" if cuda_available else "cpu"    else:        device = args.device    # Логируем информацию о GPU    logger.info(        f"{'=' * 80}\n"        f"CUDA доступна: {cuda_available}\n"        f"Выбранное устройство: {device.upper()}\n"        f"{'=' * 80}"    )    if cuda_available and device == "cuda":        gpu_name = torch.cuda.get_device_name(0)        gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3        logger.info(            f"GPU информация:\n"            f"  Название: {gpu_name}\n"            f"  Память: {gpu_memory:.2f} GB\n"            f"  Текущий индекс: {torch.cuda.current_device()}"        )    paths = []    for p in args.input:        path = Path(p).expanduser().resolve()        if path.is_dir():            # Ищем аудио и видео файлы            from transcribe_config import AUDIO_EXTENSIONS, VIDEO_EXTENSIONS            for ext in AUDIO_EXTENSIONS:                paths.extend(path.rglob(f"*{ext}"))            for ext in VIDEO_EXTENSIONS:                paths.extend(path.rglob(f"*{ext}"))        elif path.is_file():            paths.append(path)    if not paths:        logger.error("Не найдено аудио/видео файлов")        sys.exit(1)    for path in sorted(paths):        logger.info(f"\n{'═' * 80}\nОбрабатываем: {path}\n{'═' * 80}")        try:            transcribe_file(                str(path),                revision=args.revision,                device=device,                chunk_sec=args.chunk,            )        except Exception as e:            logger.error(f"Ошибка: {type(e).__name__} → {e}", exc_info=True)if __name__ == "__main__":    sys.exit(main() or 0)