#!/usr/bin/env python3# -*- coding: utf-8 -*-import osos.environ["HF_TOKEN"] = ""FFMPEG_BIN = r"C:\Tools\ffmpeg-8.0.1-full_build-shared\bin"if hasattr(os, 'add_dll_directory'):    if os.path.isdir(FFMPEG_BIN):        os.add_dll_directory(FFMPEG_BIN)        print(f"FFmpeg DLL path added: {FFMPEG_BIN}")    else:        print(f"Ошибка: папка {FFMPEG_BIN} не найдена!")else:    os.environ["PATH"] = FFMPEG_BIN + os.pathsep + os.environ.get("PATH", "")import argparseimport sysimport tempfileimport subprocessfrom pathlib import Pathimport torchfrom transformers import AutoModeldef cut_audio_to_chunks(        input_path: str,        chunk_sec: float = 25.0,        overlap_sec: float = 1.0,   # небольшой overlap помогает склейке) -> list[Path]:    """Режет аудио на куски с помощью ffmpeg, возвращает список временных wav-файлов"""    input_path = Path(input_path)    duration_cmd = ["ffmpeg", "-i", str(input_path), "-f", "null", "-"]    result = subprocess.run(duration_cmd, stderr=subprocess.PIPE, text=True)    # парсим длительность из stderr (грязно, но работает)    for line in result.stderr.splitlines():        if "Duration:" in line:            dur_str = line.split("Duration:")[1].split(",")[0].strip()            h, m, s = map(float, dur_str.split(":"))            total_sec = h*3600 + m*60 + s            break    else:        raise RuntimeError("Не удалось определить длительность аудио")    print(f"Длительность аудио: {total_sec:.1f} сек")    tmp_dir = Path(tempfile.mkdtemp(prefix="gigaam_chunks_"))    chunk_paths = []    step = chunk_sec - overlap_sec    for start_sec in range(0, int(total_sec), int(step)):        end_sec = min(start_sec + chunk_sec, total_sec)        if end_sec - start_sec < 5:  # слишком короткий — пропускаем            continue        chunk_file = tmp_dir / f"chunk_{start_sec:06d}.wav"        cmd = [            "ffmpeg", "-y", "-i", str(input_path),            "-ss", str(start_sec),            "-t", str(end_sec - start_sec),            "-ar", "16000", "-ac", "1", "-c:a", "pcm_s16le",            str(chunk_file)        ]        subprocess.run(cmd, check=True, capture_output=True, text=True)        chunk_paths.append(chunk_file)    print(f"Создано {len(chunk_paths)} чанков")    return chunk_pathsdef transcribe_file(        file_path: str,        revision: str = "e2e_rnnt",        device: str = "cuda" if torch.cuda.is_available() else "cpu",        chunk_sec: float = 25.0,):    print(f"→ Загружаем GigaAM-v3 ({revision}) на {device.upper()} ...")    model = AutoModel.from_pretrained(        "ai-sage/GigaAM-v3",        revision=revision,        trust_remote_code=True,    )    model.to(device)    model.eval()    chunks = cut_audio_to_chunks(file_path, chunk_sec=chunk_sec, overlap_sec=1.0)    texts = []    for i, chunk_path in enumerate(chunks, 1):        print(f"→ Транскрипция чанка {i}/{len(chunks)} ({chunk_path.name}) ...")        with torch.inference_mode():            text = model.transcribe(str(chunk_path))  # ← передаём строку!        texts.append(text.strip())        print(text)    full_text = " ".join(texts)    # чистим временные файлы    for p in chunks:        p.unlink()    chunks[0].parent.rmdir()  # tmp_dir    # сохранение    out_path = Path(file_path).with_suffix(f".gigaam-{revision}.txt")    out_path.write_text(full_text, encoding="utf-8")    print(f"\nГотово → {out_path}")def main():    parser = argparse.ArgumentParser(description="GigaAM-v3 для длинных аудио")    parser.add_argument("input", nargs="+", help="файл или папка")    parser.add_argument("--revision", default="e2e_rnnt",                        choices=["e2e_rnnt", "e2e_ctc", "rnnt", "ctc", "ssl"])    parser.add_argument("--device", default="auto", choices=["auto", "cpu", "cuda"])    parser.add_argument("--chunk", type=float, default=25.0, help="длина чанка (сек)")    args = parser.parse_args()    device = "cuda" if (args.device == "auto" and torch.cuda.is_available()) else args.device    paths = []    for p in args.input:        path = Path(p).expanduser().resolve()        if path.is_dir():            for ext in ("*.wav", "*.mp3", "*.m4a", "*.ogg", "*.flac", "*.aac"):                paths.extend(path.rglob(ext))        elif path.is_file():            paths.append(path)    if not paths:        print("Не найдено аудиофайлов", file=sys.stderr)        sys.exit(1)    for path in sorted(paths):        print(f"\n{'═' * 80}")        print(f"Обрабатываем: {path}")        try:            transcribe_file(                str(path),                revision=args.revision,                device=device,                chunk_sec=args.chunk,            )        except Exception as e:            print(f"Ошибка: {type(e).__name__} → {e}", file=sys.stderr)if __name__ == "__main__":    sys.exit(main() or 0)