# Копирование времени модификации для результирующих файлов

**Дата:** 2026-02-22  
**Файлы:** `transcribe_utils.py`, `t_gigaam_simple.py`, `t_gigaam_blocks.py`, `t_gigaam.py`

## 🎯 ЗАДАЧА

Выставлять дату модификации результирующего файла транскрипции такую же, как у исходного файла, чтобы они были рядом при сортировке в файловой системе.

## ✅ РЕАЛИЗАЦИЯ

### 1. Обновлена функция в `transcribe_utils.py`

```python
def save_transcription_to_file(
        full_text: str,
        input_path: Path,
        revision: str,
        suffix: str = "blocks"
) -> Path:
    """
    Сохраняет транскрипцию в текстовый файл.
    Устанавливает дату модификации результата равной дате исходного файла.
    """
    stem = input_path.stem
    parent = input_path.parent
    out_path = parent / f"{stem}.gigaam-{revision}-{suffix}.txt"

    out_path.write_text(full_text, encoding="utf-8")
    
    # Копируем время модификации исходного файла
    original_mtime = input_path.stat().st_mtime
    import os
    os.utime(out_path, (original_mtime, original_mtime))
    
    logger.info(f"Результат сохранён: {out_path}")
    
    return out_path
```

**Ключевое изменение:**
```python
# Получаем время модификации исходного файла
original_mtime = input_path.stat().st_mtime

# Устанавливаем то же время для результата
os.utime(out_path, (original_mtime, original_mtime))
```

---

### 2. Обновлён `t_gigaam_blocks.py`

Локальная функция `save_transcription_to_file()` получила аналогичное изменение:

```python
def save_transcription_to_file(full_text: str, input_path: Path, revision: str) -> Path:
    # ...создание файла...
    out_path.write_text(full_text, encoding="utf-8")
    
    # Копируем время модификации исходного файла
    original_mtime = input_path.stat().st_mtime
    os.utime(out_path, (original_mtime, original_mtime))
    
    logger.info(f"Результат сохранён: {out_path}")
    return out_path
```

---

### 3. Обновлён `t_gigaam.py`

Прямое сохранение в функции `transcribe_with_speakers()`:

```python
# Сохранение (используем имя оригинального файла)
out_path = input_path.with_suffix(f".gigaam-{revision}-speakers.txt")
out_path.write_text(full_text, encoding="utf-8")

# Копируем время модификации исходного файла
original_mtime = input_path.stat().st_mtime
os.utime(out_path, (original_mtime, original_mtime))

logger.info(f"Готово! Результат: {out_path}")
```

---

### 4. `t_gigaam_simple.py` - автоматически работает

Использует функцию `save_transcription_to_file()` из `transcribe_utils.py`, которая уже обновлена. Никаких дополнительных изменений не требуется.

---

## 📊 РЕЗУЛЬТАТ

### До изменения:

```
Сортировка по дате (в проводнике Windows):
┌────────────────────────────────────────────────┐
│ recording_2026-02-20.amr     2026-02-20 14:30 │
│ recording_2026-02-21.amr     2026-02-21 10:15 │
│ recording_2026-02-22.amr     2026-02-22 08:00 │
│ recording_2026-02-20.gigaam-e2e_rnnt-speakers.txt  2026-02-22 15:45 │ ❌
│ recording_2026-02-21.gigaam-e2e_rnnt-speakers.txt  2026-02-22 15:46 │ ❌
│ recording_2026-02-22.gigaam-e2e_rnnt-speakers.txt  2026-02-22 15:47 │ ❌
└────────────────────────────────────────────────┘
```
**Проблема:** Результаты транскрипции имеют дату создания (сегодня), а не дату исходного файла.

### После изменения:

```
Сортировка по дате (в проводнике Windows):
┌────────────────────────────────────────────────┐
│ recording_2026-02-20.amr                        2026-02-20 14:30 │
│ recording_2026-02-20.gigaam-e2e_rnnt-speakers.txt  2026-02-20 14:30 │ ✅
│ recording_2026-02-21.amr                        2026-02-21 10:15 │
│ recording_2026-02-21.gigaam-e2e_rnnt-speakers.txt  2026-02-21 10:15 │ ✅
│ recording_2026-02-22.amr                        2026-02-22 08:00 │
│ recording_2026-02-22.gigaam-e2e_rnnt-speakers.txt  2026-02-22 08:00 │ ✅
└────────────────────────────────────────────────┘
```
**Результат:** Исходный файл и его транскрипция **рядом** в списке! 🎉

---

## 🎯 ПРЕИМУЩЕСТВА

### ✅ Удобство навигации:
- Файл и его транскрипция **всегда рядом** в проводнике
- Не нужно искать соответствие по имени
- Интуитивно понятная сортировка

### ✅ Хронологический порядок:
- Сохраняется хронология записей
- Легко найти транскрипции за конкретную дату
- Полезно для CallRec и других систем записи

### ✅ Пакетная обработка:
- При обработке архива файлы сортируются правильно
- Не нарушается временная последовательность
- Удобно для бэкапов и архивации

### ✅ Интеграция:
- Работает со всеми файловыми менеджерами
- Совместимо с облачными хранилищами
- Корректная синхронизация по времени

---

## 🔧 ТЕХНИЧЕСКИЕ ДЕТАЛИ

### Функция `os.utime()`

```python
import os

# Синтаксис:
os.utime(path, (atime, mtime))
```

**Параметры:**
- `path` - путь к файлу
- `atime` - время последнего доступа (access time)
- `mtime` - время последней модификации (modification time)

**Значения времени:** Unix timestamp в секундах (float)

### Получение времени модификации:

```python
# Через Path.stat()
original_mtime = input_path.stat().st_mtime
# Возвращает float: 1708601415.123456

# Установка времени
os.utime(out_path, (original_mtime, original_mtime))
# Устанавливаем одинаковые atime и mtime
```

### Кроссплатформенность:

- ✅ **Windows:** Работает корректно
- ✅ **Linux:** Работает корректно
- ✅ **macOS:** Работает корректно

### Точность:

- **Unix timestamp:** до микросекунд
- **Файловая система:**
  - NTFS (Windows): 100 наносекунд
  - ext4 (Linux): 1 наносекунда
  - APFS (macOS): 1 наносекунда

---

## 📝 ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ

### 1. Обработка одного файла:

```bash
python t_gigaam.py recording.amr
```

**До:**
```
recording.amr                              2026-02-20 14:30
recording.gigaam-e2e_rnnt-speakers.txt     2026-02-22 15:45  ❌
```

**После:**
```
recording.amr                              2026-02-20 14:30
recording.gigaam-e2e_rnnt-speakers.txt     2026-02-20 14:30  ✅
```

---

### 2. Пакетная обработка CallRec:

```bash
python t_directory.py H:\vkshare\CallRec --script t_gigaam.py
```

**Результат в проводнике (сортировка по дате):**
```
📁 CallRec/
  📄 +7-831-call-2026-02-20_143000.amr           2026-02-20 14:30
  📄 +7-831-call-2026-02-20_143000.gigaam-...txt 2026-02-20 14:30 ✅
  📄 +7-831-call-2026-02-21_100000.amr           2026-02-21 10:00
  📄 +7-831-call-2026-02-21_100000.gigaam-...txt 2026-02-21 10:00 ✅
  📄 +7-831-call-2026-02-22_080000.amr           2026-02-22 08:00
  📄 +7-831-call-2026-02-22_080000.gigaam-...txt 2026-02-22 08:00 ✅
```

---

### 3. Архивная обработка:

```bash
python t_gigaam_simple.py H:\archive\2025\*.wav
```

Транскрипции получат даты из 2025 года, как у исходных файлов.

---

## 🧪 ПРОВЕРКА РАБОТЫ

### Команда для проверки времени файла:

**Windows (PowerShell):**
```powershell
Get-Item recording.amr | Select-Object Name, LastWriteTime
Get-Item recording.gigaam-e2e_rnnt-speakers.txt | Select-Object Name, LastWriteTime
```

**Linux/macOS:**
```bash
ls -l recording.amr
ls -l recording.gigaam-e2e_rnnt-speakers.txt
```

### Python скрипт для проверки:

```python
from pathlib import Path

original = Path("recording.amr")
result = Path("recording.gigaam-e2e_rnnt-speakers.txt")

original_time = original.stat().st_mtime
result_time = result.stat().st_mtime

print(f"Исходный файл:    {original_time}")
print(f"Результат:        {result_time}")
print(f"Совпадают: {abs(original_time - result_time) < 1}")  # Допуск 1 сек
```

---

## ⚙️ ОСОБЕННОСТИ РЕАЛИЗАЦИИ

### Где устанавливается время:

1. **`transcribe_utils.py`** - функция `save_transcription_to_file()`
   - Используется в: `t_gigaam_simple.py`

2. **`t_gigaam_blocks.py`** - локальная функция `save_transcription_to_file()`

3. **`t_gigaam.py`** - прямо в функции `transcribe_with_speakers()`

### Порядок операций:

```python
# 1. Сохраняем файл
out_path.write_text(full_text, encoding="utf-8")

# 2. Получаем время исходного файла
original_mtime = input_path.stat().st_mtime

# 3. Устанавливаем то же время для результата
os.utime(out_path, (original_mtime, original_mtime))
```

**Важно:** Устанавливаем время **после** записи файла!

---

## 💡 ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ

### Сохранение всех метаданных (если нужно в будущем):

```python
import shutil

# Копирование всех атрибутов (время, права доступа и т.д.)
shutil.copystat(input_path, out_path)
```

Но мы используем только `os.utime()`, чтобы не копировать права доступа и другие атрибуты.

---

## ✅ ИТОГ

**Реализовано копирование времени модификации во всех скриптах транскрибации!**

### Что сделано:
- ✅ Обновлена функция в `transcribe_utils.py`
- ✅ Обновлён `t_gigaam_blocks.py`
- ✅ Обновлён `t_gigaam.py`
- ✅ `t_gigaam_simple.py` автоматически использует обновлённую функцию

### Результат:
- ✅ Исходный файл и транскрипция **рядом** в проводнике
- ✅ Правильная хронологическая сортировка
- ✅ Удобство навигации и поиска
- ✅ Работает на всех платформах

### Использование:

```bash
# Любой скрипт теперь копирует дату
python t_gigaam.py recording.amr
python t_gigaam_simple.py audio.wav
python t_gigaam_blocks.py video.mp4
python t_directory.py H:\CallRec --script t_gigaam.py
```

**Готово к использованию!** Файлы теперь будут рядом в проводнике! 🎉

